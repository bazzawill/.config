Okta.CryptoManager=function(e){var s=Okta.Q,t=Okta._okta.map,p=Okta.fn.other.string.toUint8Array,a=Okta.fn.other.string.base64UrlDecode,o=Okta.fn.other.string.stringToBase64Url,i=Okta.fn.other.string.arrayBufferToBase64Url,u=Okta.fn.other.string.base64UrlToArrayBuffer,n=null,y=null,c=!e.crypto&&e.msCrypto,r={};n=e.crypto||e.msCrypto||{},y=n.subtle||n.webkitSubtle,c&&(d=function m(e,r){var t=s.defer(),o="",n=y.verify(l.algorithm,e,r.signature,r.content);return n.oncomplete=function(e){var r=e.target.result;o="signature is ",r?(o+="valid",Log.info("Crypto::validatePublicKeyIE: "+o)):(o+="not valid",Log.warn("Crypto::validatePublicKeyIE: "+o)),t.resolve({valid:!!r,message:o})},n.onerror=function(e){o="Error validating signature: "+e.target.result,Log.error("Crypto::validatePublicKeyIE: "+o),t.resolve({valid:!1,message:o})},t.promise});var l={exportedFormat:"jwk",algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usage:["verify"],isExtractable:!0};function g(){var e={supported:!0};n&&y?y.importKey?y.verify||(e.message="browser does not support crypto.subtle.verify",e.supported=!1):(e.message="browser does not support crypto.subtle.importKey",e.supported=!1):(e.message="browser does not natively support subtle crypto",e.supported=!1);var r="Crypto::isSubtleCryptoSupported: ";return e.supported?Log.info(r+"browser supports subtle crypto and the required functions"):Log.warn(r+e.message),e}function f(e){var r=String.fromCharCode.apply(null,new Uint8Array(e));return o(r)}function d(e,r){var t=s.defer(),o="",n=function(e,r){o="Error validating signature: "+e,Log.error("Crypto::validatePublicKey: "+o),r.resolve({valid:!1,message:o})};try{y.verify(l.algorithm,e,r.signature,r.content).then(function(e){o="signature is ",e?(o+="valid",Log.info("Crypto::validatePublicKey: "+o)):(o+="not valid",Log.warn("Crypto::validatePublicKey: "+o)),t.resolve({valid:!!e,message:o})})["catch"](function(e){n(e,t)})}catch(i){n(i,t)}return t.promise}return r.verifyAuthIdToken=function(i,e){return i&&e?(delete e.use,r.importKey(e,l).then(function(e){if(!e){var r="failed to import public key";return Log.error("Crypto::verifyAuthIdToken: "+r),s({valid:!1,message:r})}var t=i.split("."),o=p(t[0]+"."+t[1]),n=a(t[2]);return d(e,{signature:p(n),content:o})})):s({valid:!1,message:"no idToken or key"})},r.isSubtleCryptoSupportedForAuth=function(){var e=g();if(!e.supported)return!1;y.digest?n.getRandomValues||(e.message="browser does not support crypto.getRandomValues",e.supported=!1):(e.message="browser does not support crypto.subtle.digest",e.supported=!1);var r="Crypto::isSubtleCryptoSupported: ";return e.supported?Log.info(r+"browser supports extra crypto for Okta auth"):Log.warn(r+e.message),e.supported},r.isSubtleCryptoSupportedForCSE=function(){var e="Crypto::isSubtleCryptoSupportedForCSE: ";return!!g()&&(y.encrypt?y.decrypt?y.generateKey?y.exportKey?!!y.deriveKey||(Log.warn(e+"browser does not support crypto.subtle.deriveKey"),!1):(Log.warn(e+"browser does not support crypto.subtle.exportKey"),!1):(Log.warn(e+"browser does not support crypto.subtle.generateKey"),!1):(Log.warn(e+"browser does not support crypto.subtle.decrypt"),!1):(Log.warn(e+"browser does not support crypto.subtle.encrypt"),!1))},r.computeChallenge=c?function v(e){var r=s.defer(),t=p(e);Log.info("Crypto::computeChallengeIE: starting compute challenge..");var o=y.digest("SHA-256",t);return o.oncomplete=function(e){Log.info("Crypto::computeChallengeIE: challenge computed successfully"),r.resolve(f(e.target.result))},o.onerror=function(e){Log.info("Crypto::computeChallengeIE: Error computing challenge: "+e.target.result),r.resolve(null)},r.promise}:function(e){var r=p(e);return y.digest("SHA-256",r).then(f)},r.generateRandomString=function(e){var r=new Uint8Array(Math.ceil(e/2));return r=n.getRandomValues(r),t(r,function(e){return("0"+e.toString(16)).substr(-2)}).join("").slice(0,e)},r.encrypt=function(e,r,t){var o=s.defer();Log.info("Crypto::encrypt: starting encryption with options: "+JSON.stringify(t));var n=(new TextEncoder).encode(r);return y.encrypt(t.algorithm,e,n).then(function(e){Log.info("Crypto::encrypt: plaintext encrypted successfully!");var r=new Uint8Array(e);o.resolve(i(r))})["catch"](function(e){Log.error("Crypto::encrypt: "+e),o.reject(e)}),o.promise},r.decrypt=function(e,r,t){var o=s.defer();Log.info("Crypto::decrypt: starting decryption with options: "+JSON.stringify(t));var n=u(r);return y.decrypt(t.algorithm,e,n).then(function(e){Log.info("Crypto::decrypt: ciphertext decrypted successfully!"),o.resolve((new TextDecoder).decode(e))})["catch"](function(e){Log.error("Crypto::decrypt: "+e),o.reject(e)}),o.promise},r.generateKey=function(e){var r=s.defer();return Log.info("Crypto::generateKey: starting key generation with options: "+JSON.stringify(e)),y.generateKey(e.algorithm,e.isExtractable,e.usage).then(function(e){Log.info("Crypto::generateKey: key(s) generated successfully!"),r.resolve(e)})["catch"](function(e){Log.error("Crypto::generateKey: "+e),r.reject(e)}),r.promise},r.importKey=function(e,r){if(c)return function i(e,r){var t=s.defer();e.extractable=r.isExtractable;var o=p(JSON.stringify(e));Log.info("Crypto::importKeyIE: starting key import..");var n=y.importKey(r.exportedFormat,o.buffer,r.algorithm,r.isExtractable,r.usage);return n.oncomplete=function(e){Log.info("Crypto::importKeyIE: key imported successfully"),t.resolve(e.target.result)},n.onerror=function(e){Log.warn("Crypto::importKeyIE: Error importing key: "+e.target.result),t.resolve(null)},t.promise}(e,r);var t=s.defer(),o=function(e,r){Log.warn("Crypto::importKey: Error importing key: "+e),r.resolve(null)};Log.info("Crypto::importKey: starting key import..");try{y.importKey(r.exportedFormat,e,r.algorithm,r.isExtractable,r.usage).then(function(e){Log.info("Crypto::importKey: key imported successfully"),t.resolve(e)})["catch"](function(e){o(e,t)})}catch(n){o(n,t)}return t.promise},r.exportKey=function(e,r){var t=s.defer();return Log.info("Crypto::exportKey: exporting key to "+r),y.exportKey(r,e).then(function(e){Log.info("Crypto::exportKey: key exported successfully!"),t.resolve(e)})["catch"](function(e){Log.error("Crypto::exportKey: "+e),t.reject(e)}),t.promise},r.deriveKey=function(e,r,t){var o="Crypto::deriveKey: ",n=s.defer(),i=function(e,r){Log.error(o+" Error deriving key: "+e),r.reject(e)};Log.info(o+"starting key derivation");try{y.deriveKey({name:t.algorithm.name,salt:p(r),iterations:t.algorithm.iterations,hash:t.algorithm.hash},e,{name:t.derivedKeyAlgorithm.name,length:t.derivedKeyAlgorithm.length},!0,t.derivedKeyAlgorithm.usage).then(function(e){Log.info(o+"key derived successfully!"),n.resolve(e)})["catch"](function(e){i(e,n)})}catch(a){i(a,n)}return n.promise},r};